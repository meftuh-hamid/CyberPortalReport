/**
* DevExpress Analytics (query-builder\dataSource\dbSchemaProvider.js)
* Version:  22.2.4
* Build date: Jan 25, 2023
* Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as ko from 'knockout';
import * as $ from 'jquery';
import { Disposable } from '../../serializer/utils';
import { getDBSchemaCallback, getDBStoredProceduresCallback } from './_dbSchemaProvider';
import { RequestWrapper } from '../utils/requestwrapper';
import { findFirstItemMatchesCondition } from '../../core/utils/_arrayutils';
import { isCustomizedWithUpdateLocalizationMethod } from '../../property-grid/localization/_localization';
import { getLocalization } from '../../property-grid/localization/localization_utils';
import { formatUnicorn } from '../../property-grid/widgets/internal/_utils';
export class DBSchemaProvider extends Disposable {
    constructor(connection, _requestWrapper = new RequestWrapper()) {
        super();
        this._requestWrapper = _requestWrapper;
        this._tables = {};
        this._tableRequests = ko.observableArray([]).extend({ deferred: true });
        this.connection = connection;
        this._disposables.push(this.connection.name.subscribe(() => {
            this._tables = {};
            this._dbSchema = null;
            this._dbStoredProceduresSchema = null;
        }));
        this._disposables.push(ko.computed(() => {
            var tableRequests = this._tableRequests();
            if (!tableRequests.length)
                return;
            this._tableRequests([]);
            var tables = tableRequests.map(x => x.table);
            this._getDBSchema(tables).done(dbSchema => {
                tableRequests.forEach(tableRequest => {
                    var schemaTable = dbSchema.tables.filter(x => x.name === tableRequest.table.name)[0];
                    if (!schemaTable) {
                        tableRequest.deferred.reject();
                        return;
                    }
                    tableRequest.table.columns = schemaTable.columns;
                    tableRequest.deferred.resolve(tableRequest.table);
                });
            }).fail(() => tableRequests.forEach(request => request.deferred.reject()));
        }));
        this.getItems = (pathRequest) => {
            var deferred = $.Deferred();
            if (!pathRequest.fullPath) {
                this.getDbSchema().done((dbSchema) => {
                    deferred.resolve($.map(dbSchema.tables, (item) => {
                        var dataMemberInfo = {
                            name: item.name,
                            displayName: item.name,
                            isList: false,
                            specifics: item.isView ? 'view' : 'table',
                            dragData: { noDragable: false }
                        };
                        return dataMemberInfo;
                    }));
                });
            }
            else {
                deferred.resolve([]);
            }
            return deferred.promise();
        };
    }
    _getDBSchema(tables) {
        return this._getDBSchemaCallback(this.connection, tables);
    }
    _getDBSchemaCallback(connection, tables) {
        return getDBSchemaCallback(this._requestWrapper, connection, tables);
    }
    _getDBStoredProcedures(connection) {
        return getDBStoredProceduresCallback(this._requestWrapper, connection);
    }
    getDbSchema() {
        if (!this._dbSchema || this._dbSchema.state() === 'rejected')
            this._dbSchema = this._getDBSchema();
        return this._dbSchema;
    }
    getDbStoredProcedures() {
        if (!this._dbStoredProceduresSchema || this._dbStoredProceduresSchema.state() === 'rejected')
            this._dbStoredProceduresSchema = this._getDBStoredProcedures(this.connection);
        return this._dbStoredProceduresSchema;
    }
    getDbTable(tableName) {
        if (!this._tables[tableName]) {
            var deferred = $.Deferred();
            this._tables[tableName] = deferred.promise();
            this.getDbSchema().done((dbSchema) => {
                var table = findFirstItemMatchesCondition(dbSchema.tables, table => table.name === tableName);
                if (!table) {
                    deferred.reject();
                    isCustomizedWithUpdateLocalizationMethod('The schema does not contain the specified table: ') ?
                        getLocalization('The schema does not contain the specified table: ') + "'" + tableName + "'." :
                        formatUnicorn(getLocalization('The schema does not contain the specified table: "{0}".', 'DataAccessStringId.TableNotInSchemaValidationException'), tableName);
                }
                else if (table.columns.length > 0) {
                    deferred.resolve(table);
                }
                else {
                    this._tableRequests.push({ table: table, deferred: deferred });
                }
            }).fail(() => deferred.reject());
        }
        return this._tables[tableName];
    }
}
